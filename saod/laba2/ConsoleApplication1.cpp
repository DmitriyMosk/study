#include "Header.h"


int main()
{
	struct node_trie* root = create_node('\0');

	ifstream file("words.txt");


	char str[100];

	char* temp_word;

	for (int i = 0; i < 50000; i++)
	{
		file.getline(str, 100);

		temp_word = new char[strlen(str) + 1];

		strcpy(temp_word, str);

		root = insert(root, temp_word);



		//cout << dictionary[i] << endl;

		delete temp_word;
	}

	print_search(root, "yhnreewit");

	//print_trie(root);
	free_trie(root);

	/*
	
	print_trie(root);

	*/
	file.close();
	return 0;

}
/*
1) Объяснить основные алгоритмы для работы с префиксными деревьями:


	это структура данных, которая хранит набор строк и позволяет эффективно выполнять операции поиска, вставки и удаления. Основные алгоритмы для работы с префиксными деревьями включают:

	1. Вставка элемента:ля вставки нового элемента в префиксное дерево нужно начать с корневого узла и последовательно переходить от узла к узлу, 
	соответствующему каждой букве вставляемой строки.

	2. Удаление элемента: Для удаления элемента из префиксного дерева нужно начать с корневого узла и последовательно переходить от узла к узлу, 
	соответствующему каждой букве удаляемой строки.

	3. Поиск элемента: Для поиска элемента в префиксном дереве нужно начать с корневого узла и последовательно переходить от узла к узлу, 
	соответствующему каждой букве искомой строки.

2) Существуют несколько подходов к хранению списков дочерних узлов в префиксном дереве:

	1. Массив: Каждый узел хранит массив указателей на своих дочерних узлов, где каждый индекс соответствует определенной букве алфавита. Этот подход обеспечивает быстрый доступ к дочерним узлам, но требует большого объема памяти, особенно если алфавит содержит много символов.

	2. Список: Каждый узел хранит список своих дочерних узлов. Этот подход экономичен по памяти, но может быть не очень эффективным при поиске и вставке элементов, особенно если список дочерних узлов большой.

	3. Хеш-таблица: Каждый узел хранит хеш-таблицу своих дочерних узлов, где ключом является буква алфавита. Этот подход обеспечивает быстрый доступ к дочерним узлам и экономичен по памяти, но может быть не очень эффективным при большом количестве коллизий.

	4. Дерево поиска: Каждый узел хранит дерево поиска своих дочерних узлов, где каждый узел представляет собой букву алфавита. Этот подход обеспечивает быстрый поиск и вставку элементов, но может быть не очень эффективным при большом количестве дочерних узлов.

3) Как модифицировать код программы для реализации упорядоченного словаря (ordered map)?

	Для реализации упорядоченного словаря можно использовать дерево поиска, где каждый узел хранит пару ключ-значение. 
	Ключи должны быть упорядочены, например, в алфавитном порядке или по числовому значению. 
	При поиске или вставке элементов нужно использовать сравнение ключей для определения места вставки или поиска.

4) Провести сравнительный анализ вычислительной сложности операций префиксного дерева,
сбалансированного дерева поиска (red-black / AVL tree) и хеш-таблицы при хранении данных со
строковыми ключами

	Префиксное дерево:
	- Вставка: O(m), где m - длина ключа
	- Поиск: O(m), где m - длина ключа
	- Удаление: O(m), где m - длина ключа
	Префиксное дерево имеет лучшую производительность при работе с большим количеством строковых ключей с общим префиксом.

	Сбалансированное дерево поиска (red-black / AVL tree):
	- Вставка: O(log n), где n - количество элементов
	- Поиск: O(log n), где n - количество элементов
	- Удаление: O(log n), где n - количество элементов
	Сбалансированные деревья поиска обеспечивают логарифмическую сложность операций независимо от размера данных и хорошо подходят для работы с большим количеством элементов.

	Хеш-таблица:
	- Вставка: O(1)
	- Поиск: O(1)
	- Удаление: O(1)
	Хеш-таблицы имеют константную сложность операций, но могут потребовать большой объем памяти для хранения большого количества элементов. Кроме того, при коллизиях может возникнуть необходимость в дополнительных операциях для разрешения конфликтов.


5) Описать принцип работы вариаций префиксного дерева: bitwise tree, radix tree, suffix tree:

	Bitwise tree - это вариация префиксного дерева, которая используется для хранения битовых строк. 
	Каждый узел дерева представляет собой бит, а ребра - следующий бит в строке. Это позволяет эффективно хранить и обрабатывать битовые строки.

	Radix tree - это вариация префиксного дерева, которая используется для хранения строк, но в отличие от обычного префиксного дерева, 
	группирует узлы с общими префиксами в один узел. Это позволяет снизить количество узлов и уменьшить объем памяти, необходимый для хранения дерева.

	Suffix tree - это вариация префиксного дерева, которая используется для хранения суффиксов строки. Каждый узел дерева представляет собой суффикс строки, 
	а ребра - следующий символ в суффиксе. Это позволяет эффективно находить все вхождения подстроки в строке и решать другие задачи, связанные со строками

*/